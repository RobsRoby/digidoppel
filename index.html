<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DigiDoppel</title>
    
    <link href='https://fonts.googleapis.com/css?family=Poppins' rel='stylesheet'>
    <link rel="icon" type="image/x-icon" href="icon.png">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <!-- Import maps for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.152.0/examples/jsm/"
            }
        }
    </script>
    <!-- Load Mediapipe and its dependencies using script tags -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    
</head>
<body>
    <video id="videoElement" autoplay></video>
    <div class="container">
        <h1 class="display-4"><img src="icon-text.png" height="200px"></h1>
        <p class="lead"> Your Virtual Twin, Secure and Personalized.</p>
        <canvas id="avatarCanvas" width="300" height="300"></canvas>
        
        <!-- File uploader with custom design -->
        <div class="file-loader">
            <label for="fileUploader" class="file-label">
                <i class="fas fa-upload"></i> Change Background
            </label>
            <input type="file" id="fileUploader" accept="image/*">
        </div>
        
        <div class="recording-controls">
            <button id="startRecording" class="btn"><i class="fas fa-record-vinyl"></i> Start</button>
            <button id="stopRecording" class="btn" disabled><i class="fas fa-stop"></i> Stop</button>
            <video id="recordingPreview" controls width="300"></video>
        </div>
        
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
    
        const avatarCanvas = document.getElementById('avatarCanvas');
        const videoElement = document.getElementById('videoElement');
        const fileUploader = document.getElementById('fileUploader');
    
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, avatarCanvas.width / avatarCanvas.height, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: avatarCanvas, alpha: true });
        renderer.setSize(avatarCanvas.width, avatarCanvas.height);
        camera.position.z = 240;
    
        const loader = new FBXLoader();
        let faceModel;
    
        loader.load('head.fbx', (object) => {
            faceModel = object;
            scene.add(faceModel);
        });
    
        const light = new THREE.AmbientLight(0x404040,30);
        scene.add(light);
    
        function onResults(results) {
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0 && faceModel) {
                const landmarks = results.multiFaceLandmarks[0];
    
                const nose = landmarks[1];
                faceModel.position.set((nose.x - 0.5) * 2, -(nose.y + 5) * 2, 0);
    
                const leftCheek = landmarks[234];
                const rightCheek = landmarks[454];
                const faceWidth = Math.sqrt(Math.pow(leftCheek.x - rightCheek.x, 2) + Math.pow(leftCheek.y - rightCheek.y, 2));
                faceModel.scale.set(faceWidth, faceWidth, faceWidth);
            }
            renderer.render(scene, camera);
        }
    
        async function loadFaceMeshModel() {
            const faceMesh = new FaceMesh({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
            });
    
            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
    
            faceMesh.onResults(onResults);
    
            videoElement.srcObject = await navigator.mediaDevices.getUserMedia({ video: true });
            const cameraMP = new Camera(videoElement, {
                onFrame: async () => await faceMesh.send({ image: videoElement }),
                width: 640,
                height: 480
            });
    
            cameraMP.start();
        }
    
        loadFaceMeshModel();

        // Handle file upload and change avatar background
        fileUploader.addEventListener('change', (event) => {
            const file = event.target.files[0];
            const reader = new FileReader();
            reader.onload = function(e) {
                avatarCanvas.style.backgroundImage = `url(${e.target.result})`;
            }
            reader.readAsDataURL(file);
        });
    </script>

    <script>
    let mediaRecorder;
    let recordedChunks = [];

    const startRecordingButton = document.getElementById('startRecording');
    const stopRecordingButton = document.getElementById('stopRecording');
    const recordingPreview = document.getElementById('recordingPreview');

    startRecordingButton.addEventListener('click', () => {
        startRecordingButton.disabled = true;
        stopRecordingButton.disabled = false;
        
        const canvasStream = avatarCanvas.captureStream(30); // Adjust FPS if necessary
        mediaRecorder = new MediaRecorder(canvasStream, {
            mimeType: 'video/webm; codecs=vp9'
        });

        mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        };

        mediaRecorder.onstop = () => {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const videoURL = URL.createObjectURL(blob);
            recordingPreview.src = videoURL;
            recordingPreview.style.display = 'block'; // Ensure preview is visible
            recordedChunks = []; // Reset chunks for next recording
        };

        mediaRecorder.start();
    });

    stopRecordingButton.addEventListener('click', () => {
        startRecordingButton.disabled = false;
        stopRecordingButton.disabled = true;
        mediaRecorder.stop();
    });
    </script>

</body>
</html>
